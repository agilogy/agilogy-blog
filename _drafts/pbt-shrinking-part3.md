---
layout: post
title:  "Property based testing: Shrinking (part 1)"
date:   2022-05-15 19:01:57 +0200
categories: kotlin
---

## Shrinking in PBT libraries

The intuitive idea of shrinking consists of reducing the _size_ of a value. Let's take the set of tags we want to use to filter items: `Set(Tag.clothes, Tag.exclusive)`. We could shrink it by removing elements from the set. Acording to this idea, `setOf(Tag.clothes)` would be intuitively one step smaller than the original value, as it would be `setOf(Tag.exclusive)`. If any of those simpler values still failed the test, we could shrink further by taking `emptySet()`, which would be 2 _steps_ smaller than the original value.

For the library to be able to shrink values of some type `T`, it needs some function that allows us to shrink a value of type `T`. Like it happens with the example above, there may be more than one way to shrink such a value. The `ItemFilter` type, for example, may be shrinked by shrinking `minWeightInKgs`, `maxWeightInKgs`, `olderThan` or `hasAllTags`. At the same time, there may be multiple ways to shrink each of these components.

Therefore, the shrinking function should be a function from `T` to a `List` of possible one-step shrinkings of T. For each of these shrinked values, we can apply the shrinking function to get a new List of possible two-step shrinkings. The recursive application of the shrinking function gives us a (potentially very large) shrinking tree.



Therefore, there is a way of attaching a shrinking function to a generator:

```kotlin
fun <A> Arb<A>.shrinkingTo(f: (A) -> List<A>) =
  arbitrary(Shrinker { value -> f(value) }) { this@shrinkingTo.bind() }
```

Whenever a test fails with some sample, the process of shrinking, consists of traversing the shrinking tree generated by the recursive application of the shrinking function on the value, in a depth-first order, trying to find the most shrinked (deepest) value in the tree that still fails the test. For that purpose, the test is run with values in the shrinking tres.

### Small detour: On generators ` map` function and the shrinking function

A generator of values of type `T`, usually called `Gen<T>`, has a functor, meaning that you can `map` it with a pure function to return a generator of a new type. e.g. For a generator `g` of type `Gen<Int>`, `g.map{it.toString()}` returns a generator of type `Gen<String>` that generates strings that represent integer numbers.

Let's say a generator `Gen<T>` has been provided with a shrinking function  (e.g.: a shrinking function `(Int) => List<Int>`). Now, we can `map` our generator to another type `R`and we would like to keep the shrinking function we already had. In the `Int` example, imagine the shrinking function was `(value:Int) => {listOf(max(0,value-1))}`. How can we calculate the mapped shrinking function of type `(String) => List<String>`? We can't. We would need to convert the input `String` into an `Int` to be able to apply the `Int` shrinking funciton we had.

Kotest resolves this applying a neat trick: You can attach a shrinking function to a generator, but, internally, the generator always generates a value with the (lazy) tree of shrinked values:

```kotlin
data class Sample<out A>(val value: A, val shrinks: RTree<A> = RTree({ value }))
data class RTree<out A>(val value: () -> A, val children: Lazy<List<RTree<A>>> = lazy { emptyList<RTree<A>>() })
```

Note: I think `Sample.value` is unnecessarily repeated here, as `Sample.shrinks.value()` holds the same value and it may be evaluated eagerly.

How does that change our problem? Now, for any given `Gen<A>` you can `map` with a function `f: (A) => B` and get a generator that generates instances of `Sample<B>` by just generating a `Sample<A>` and mapping its value and all of its shrinking tree with `f`.



## Generalizing shrinking

- TODO: ADTs: Union types + product types
